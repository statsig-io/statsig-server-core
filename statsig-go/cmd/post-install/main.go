package main

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"

	fileOps "github.com/statsig-io/statsig-server-core/statsig-go/file-ops"
)

const (
	version = "0.9.1-rc.2509181925"
)

var output_dir string

func find_output_dir() {
	userCache, err := os.UserCacheDir()
	if err != nil {
		panic(fmt.Sprintf("cannot determine cache dir: %v", err))
	}
	output_dir = filepath.Join(userCache, "statsig", "resources")

	// On Windows, ensure we have a valid path
	if runtime.GOOS == "windows" {
		// Convert to absolute path to handle any potential issues
		absPath, err := filepath.Abs(output_dir)
		if err != nil {
			panic(fmt.Sprintf("cannot resolve output dir path: %v", err))
		}
		output_dir = absPath
	}
}

func writeEnvSetupScript() {
	cacheDir := output_dir
	homeDir, err := os.UserHomeDir()
	if err != nil {
		panic(err)
	}

	switch runtime.GOOS {
	case "windows":
		// PowerShell syntax
		psScript := fmt.Sprintf(`$env:STATSIG_LIB_DIR = "%s"
$env:CGO_ENABLED = "1"
$env:CGO_CFLAGS = "-I$env:STATSIG_LIB_DIR"
$env:CGO_LDFLAGS = "-L$env:STATSIG_LIB_DIR"
$env:PATH = "$env:STATSIG_LIB_DIR;$env:PATH"
Write-Host "✅ Statsig FFI environment variables set."
`, cacheDir)

		scriptPath := filepath.Join(homeDir, ".statsig_env.ps1")
		if err := os.WriteFile(scriptPath, []byte(psScript), 0644); err != nil {
			panic(err)
		}

		fmt.Println("\nTo enable Statsig Go Core SDK in your current PowerShell session, run:")
		fmt.Printf("    . \"%s\"\n", scriptPath)
		fmt.Println("\nOr to load it automatically in all future sessions, add the above line to your PowerShell profile.")

	case "darwin", "linux":
		// Bash/Zsh syntax
		shScript := fmt.Sprintf(`# Statsig FFI environment setup
# Generated by Statsig Go Core SDK post-install script. Do not edit manually.
export STATSIG_LIB_DIR="%s"
export CGO_ENABLED="1"
export CGO_CFLAGS="-I$STATSIG_LIB_DIR"
export CGO_LDFLAGS="-L$STATSIG_LIB_DIR"
export DYLD_LIBRARY_PATH="$STATSIG_LIB_DIR"
export LD_LIBRARY_PATH="$STATSIG_LIB_DIR"
echo "✅ Statsig FFI environment variables set."
`, cacheDir)

		scriptPath := filepath.Join(homeDir, ".statsig_env")
		if err := os.WriteFile(scriptPath, []byte(shScript), 0644); err != nil {
			panic(err)
		}

		fmt.Println("\nTo enable Statsig Go Core SDK in your current shell, run:")
		fmt.Printf("    source %s\n", scriptPath)
		fmt.Println("\nOr to load it automatically in all future shells, add the above line to your ~/.bashrc or ~/.zshrc.")

	default:
		fmt.Printf("❌ Unsupported OS: %s\n", runtime.GOOS)
		os.Exit(1)
	}
}

func get_amazon_linux_os() *string {
	osFile := "/etc/os-release"

	if _, err := os.Stat(osFile); os.IsNotExist(err) {
		return nil
	}

	osRelease, err := os.ReadFile(osFile)
	if err != nil {
		return nil
	}

	if strings.Contains(string(osRelease), "Amazon Linux 2023") {
		amazonLinux2023 := "amazonlinux2023"
		return &amazonLinux2023
	}

	if strings.Contains(string(osRelease), "Amazon Linux 2") {
		amazonLinux2 := "amazonlinux2"
		return &amazonLinux2
	}

	return nil
}

func get_os() *string {
	switch runtime.GOOS {
	case "darwin":
		macos := "macos"
		return &macos
	case "linux":
		linux := "linux"
		return &linux
	case "windows":
		windows := "windows"
		return &windows
	default:
		return nil
	}
}

func get_system_info() []string {
	arch := runtime.GOARCH

	if arch == "amd64" || arch == "x86_64" {
		arch = "x86_64"
	} else if arch == "arm64" || arch == "aarch64" {
		arch = "aarch64"
	} else if arch == "386" || arch == "i386" {
		fmt.Println("32 bit windwos architecture is not supported: ", arch)
		os.Exit(1)
	} else {
		fmt.Println("Unsupported architecture: ", arch)
		os.Exit(1)
	}
	var osStr string

	osVal := get_amazon_linux_os()
	if osVal == nil {
		osVal = get_os()
	}

	if osVal == nil {
		fmt.Println("Unsupported OS: ", osVal)
		os.Exit(1)
	} else {
		osStr = *osVal
	}

	fmt.Println("\n-- System Info --")
	fmt.Printf(" OS: %s\n", osStr)
	fmt.Printf(" Arch: %s\n", arch)
	fmt.Println("-----------------")

	return []string{osStr, arch}
}

func isDir(path string) bool {
	info, err := os.Stat(path)
	if err != nil {
		return false
	}
	return info.IsDir()
}

func ensure_bin_dir_exists(ops fileOps.FileOps) {
	if isDir(output_dir) {
		fmt.Println("Output directory already exists:", output_dir)
		return
	}

	if !ops.Mkdir(output_dir, 0755, true) {
		fmt.Println("Failed to create directory:", output_dir)
		os.Exit(1)
	}

	// Verify the directory was actually created
	if !isDir(output_dir) {
		fmt.Println("Directory creation appeared to succeed but directory does not exist:", output_dir)
		os.Exit(1)
	}

	fmt.Println("Successfully created output directory:", output_dir)
}

func remove_existing_statsig_resources() {
	dir := output_dir

	files, err := os.ReadDir(dir)
	if err == nil {
		for _, file := range files {
			if strings.Contains(file.Name(), "statsig_ffi") {
				os.Remove(filepath.Join(dir, file.Name()))
			}
		}
	}

}

func isMuslFromFileSystem() *bool {
	output, err := os.ReadFile("/usr/bin/ldd")
	if err != nil {
		return nil
	}

	if strings.Contains(string(output), "musl") {
		val := true
		return &val
	}

	val := false
	return &val
}

func isMuslFromChildProcess() bool {
	cmd := exec.Command("ldd", "--version")
	output, err := cmd.Output()
	if err != nil {
		return false
	}

	if strings.Contains(string(output), "musl") {
		return true
	}

	return false
}

func isMusl(os string) bool {
	if os != "linux" {
		return false
	}

	musl := isMuslFromFileSystem()
	if musl == nil {
		val := isMuslFromChildProcess()
		musl = &val
	}
	return *musl
}

func download_binary(system_info []string, ops fileOps.FileOps) string {

	binary_map := map[string]string{

		"macos-aarch64": "statsig-ffi-" + version + "-aarch64-apple-darwin-shared.zip",
		"macos-x86_64":  "statsig-ffi-" + version + "-x86_64-apple-darwin-shared.zip",

		"linux-aarch64": "statsig-ffi-" + version + "-centos7-aarch64-unknown-linux-gnu-shared.zip",
		"linux-x86_64":  "statsig-ffi-" + version + "-centos7-x86_64-unknown-linux-gnu-shared.zip",

		"linux-aarch64-musl": "statsig-ffi-" + version + "-alpine-aarch64-unknown-linux-musl-shared.zip",
		"linux-x86_64-musl":  "statsig-ffi-" + version + "-alpine-x86_64-unknown-linux-musl-shared.zip",

		"windows-x86_64": "statsig-ffi-" + version + "-x86_64-pc-windows-msvc-shared.zip",
		"windows-i686":   "statsig-ffi-" + version + "-i686-pc-windows-msvc-shared.zip",
	}

	system_tag := system_info[0] + "-" + system_info[1]
	if isMusl(system_info[0]) {
		system_tag += "-musl"
	}

	binary_file, ok := binary_map[system_tag]
	if !ok {
		fmt.Println("No binary found for: ", system_tag)
		os.Exit(1)
	}

	url := "https://github.com/statsig-io/statsig-server-core/releases/download/" + version + "/" + binary_file

	fmt.Println("\n-- Downloading Statsig FFI Binary --")
	fmt.Println(" Url: ", url)
	fmt.Println(" Output Path: ", filepath.Join(output_dir, binary_file))
	fmt.Println("-----------------------------------")

	output_path := filepath.Join(output_dir, binary_file)

	if err := ops.DownloadFile(url, output_path); err != nil {
		fmt.Println("Failed to download file:", err)
		os.Exit(1)
	}

	return output_path

}

func download_header(ops fileOps.FileOps) {

	url := "https://github.com/statsig-io/statsig-server-core/releases/download/" + version + "/statsig_ffi.h"

	fmt.Println("\n-- Downloading Statsig FFI Header --")
	fmt.Println(" Url: ", url)
	fmt.Println(" Output Path: " + filepath.Join(output_dir, "statsig_ffi.h"))
	fmt.Println("-----------------------------------")

	output_path := filepath.Join(output_dir, "statsig_ffi.h")

	if err := ops.DownloadFile(url, output_path); err != nil {
		fmt.Println("Failed to download file:", err)
		os.Exit(1)
	}

}

func fileExists(filename string) bool {
	_, err := os.Stat(filename)
	if err == nil {
		return true
	}
	if os.IsNotExist(err) {
		return false
	}
	return false
}

func ensure_header_file_exists() bool {
	header_file := filepath.Join(output_dir, "statsig_ffi.h")

	if !(fileExists(header_file)) {
		fmt.Println("❌ Required header file not found at:", header_file)
		return false
	} else {
		fmt.Println("✅ Header file found at:", header_file)
		return true
	}
}

func ensure_binary_file_exists(system_info []string) bool {
	binary_name := "libstatsig_ffi.so"
	if system_info[0] == "macos" {
		binary_name = "libstatsig_ffi.dylib"
	} else if system_info[0] == "windows" {
		binary_name = "statsig_ffi.dll"
	}

	binary_file := filepath.Join(output_dir, binary_name)

	if !(fileExists(binary_file)) {
		fmt.Println("❌ Required binary file not found at:", binary_file)
		return false
	} else {
		fmt.Println("✅ Binary file found at:", binary_file)
		return true
	}
}

func fixDylibPath(outputDir string) error {
	dylibPath := filepath.Join(outputDir, "libstatsig_ffi.dylib")

	libDir := os.Getenv("STATSIG_LIB_DIR")
	if libDir == "" {
		libDir = outputDir
	}

	// force path to reference statsig_lib_dir
	installName := filepath.Join(libDir, "libstatsig_ffi.dylib")

	cmd := exec.Command("install_name_tool", "-id", installName, dylibPath)
	out, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("failed to run install_name_tool: %v, output: %s", err, string(out))
	}

	fmt.Printf("✅ Patched dylib install name to: %s\n", installName)
	return nil
}

func main() {

	find_output_dir()

	ops := fileOps.GetFileOps()
	if os.Getenv("SKIP_STATSIG_POST_INSTALL") == "true" {
		os.Exit(0)
	}

	system_info := get_system_info()
	ensure_bin_dir_exists(ops)
	remove_existing_statsig_resources()

	zip_file_path := download_binary(system_info, ops)

	if err := ops.UnzipBinary(zip_file_path, output_dir); err != nil {
		fmt.Println("Unzip failed:", err)
		os.Exit(1)
	}

	download_header(ops)

	fmt.Println("\n-- Ensuring Resources Exist --")
	header_found := ensure_header_file_exists()
	binary_found := ensure_binary_file_exists(system_info)
	fmt.Println("-----------------------------------")

	if !header_found || !binary_found {
		fmt.Println("Missing resources after install!")
		os.Exit(1)
	}

	// Fix dylib path on macOS
	if runtime.GOOS == "darwin" {
		if err := fixDylibPath(output_dir); err != nil {
			fmt.Println("Warning: Failed to fix dylib path:", err)
		}
	}

	writeEnvSetupScript()
	fmt.Println("✅ Statsig Go Core SDK post-install completed successfully.")
}
