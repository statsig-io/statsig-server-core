// This file is @generated by prost-build.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SpecsEnvelope {
    #[prost(enumeration = "SpecsEnvelopeKind", tag = "1")]
    pub kind: i32,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub checksum: ::prost::alloc::string::String,
    #[prost(bytes = "vec", optional, tag = "4")]
    pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SpecsTopLevel {
    #[prost(bool, tag = "1")]
    pub has_updates: bool,
    #[prost(uint64, tag = "2")]
    pub time: u64,
    #[prost(string, tag = "3")]
    pub company_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub response_format: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub checksum: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "7")]
    pub rest: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Spec {
    #[prost(string, tag = "1")]
    pub salt: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub enabled: bool,
    #[prost(message, optional, tag = "3")]
    pub default_value: ::core::option::Option<ReturnValue>,
    #[prost(enumeration = "EntityType", tag = "4")]
    pub entity: i32,
    #[prost(message, optional, tag = "5")]
    pub id_type: ::core::option::Option<IdType>,
    #[prost(uint32, tag = "6")]
    pub version: u32,
    #[prost(message, repeated, tag = "7")]
    pub rules: ::prost::alloc::vec::Vec<Rule>,
    #[prost(bool, optional, tag = "8")]
    pub is_active: ::core::option::Option<bool>,
    #[prost(string, repeated, tag = "9")]
    pub explicit_parameters: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "10")]
    pub has_shared_params: ::core::option::Option<bool>,
    #[prost(string, repeated, tag = "11")]
    pub target_app_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "12")]
    pub use_new_layer_eval: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "13")]
    pub forward_all_exposures: ::core::option::Option<bool>,
    #[prost(string, repeated, tag = "14")]
    pub fields_used: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Rule {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub pass_percentage: u32,
    #[prost(string, tag = "3")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "4")]
    pub salt: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "5")]
    pub conditions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "6")]
    pub id_type: ::core::option::Option<IdType>,
    #[prost(message, optional, tag = "7")]
    pub return_value: ::core::option::Option<ReturnValue>,
    #[prost(string, optional, tag = "8")]
    pub group_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "9")]
    pub config_delegate: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "10")]
    pub is_experiment_group: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "11")]
    pub is_control_group: ::core::option::Option<bool>,
    #[prost(float, optional, tag = "12")]
    pub sampling_rate: ::core::option::Option<f32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Condition {
    #[prost(enumeration = "ConditionType", tag = "1")]
    pub condition_type: i32,
    #[prost(message, optional, tag = "2")]
    pub id_type: ::core::option::Option<IdType>,
    #[prost(message, optional, tag = "3")]
    pub target_value: ::core::option::Option<AnyValue>,
    #[prost(enumeration = "Operator", optional, tag = "4")]
    pub operator: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "5")]
    pub field: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes = "vec", optional, tag = "6")]
    pub additional_values: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnyValue {
    #[prost(oneof = "any_value::Value", tags = "1, 2, 3, 4, 5, 6")]
    pub value: ::core::option::Option<any_value::Value>,
}
/// Nested message and enum types in `AnyValue`.
pub mod any_value {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(string, tag = "1")]
        StringValue(::prost::alloc::string::String),
        #[prost(bool, tag = "2")]
        BoolValue(bool),
        #[prost(int64, tag = "3")]
        Int64Value(i64),
        #[prost(uint64, tag = "4")]
        Uint64Value(u64),
        #[prost(double, tag = "5")]
        DoubleValue(f64),
        #[prost(bytes, tag = "6")]
        RawValue(::prost::alloc::vec::Vec<u8>),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReturnValue {
    #[prost(oneof = "return_value::Value", tags = "1, 2")]
    pub value: ::core::option::Option<return_value::Value>,
}
/// Nested message and enum types in `ReturnValue`.
pub mod return_value {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Value {
        #[prost(bool, tag = "1")]
        BoolValue(bool),
        #[prost(bytes, tag = "2")]
        RawValue(::prost::alloc::vec::Vec<u8>),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IdType {
    #[prost(oneof = "id_type::IdType", tags = "1, 2")]
    pub id_type: ::core::option::Option<id_type::IdType>,
}
/// Nested message and enum types in `IdType`.
pub mod id_type {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum IdType {
        #[prost(enumeration = "super::KnownIdType", tag = "1")]
        KnownIdType(i32),
        #[prost(string, tag = "2")]
        CustomIdType(::prost::alloc::string::String),
    }
}
/// *
///
/// Key names to be deleted from the DCS' top-level fields.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RulesetsResponseDeletions {
    #[prost(string, repeated, tag = "1")]
    pub dynamic_configs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "2")]
    pub feature_gates: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "3")]
    pub layer_configs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "4")]
    pub experiment_to_layer: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "5")]
    pub condition_map: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "6")]
    pub sdk_configs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "7")]
    pub param_stores: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "8")]
    pub cmab_configs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "9")]
    pub override_rules: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "10")]
    pub overrides: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RulesetsChecksums {
    /// Map of checksums, representing all of the entity checksums combined
    /// e.g.
    /// {
    /// "dynamic_configs": 1234,
    /// "layer_configs": 4567,
    /// ...
    /// }
    #[prost(map = "string, uint64", tag = "1")]
    pub field_checksums: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        u64,
    >,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SpecsEnvelopeKind {
    Unknown = 0,
    Done = 1,
    /// SpecsTopLevel
    TopLevel = 2,
    /// Spec
    FeatureGate = 3,
    /// Spec
    DynamicConfig = 4,
    /// Spec
    LayerConfig = 5,
    /// ParamStore
    ParamStore = 6,
    /// Condition
    Condition = 7,
    /// RulesetsResponseDeletions
    Deletions = 8,
    /// RulesetsChecksums
    Checksums = 9,
    CopyPrev = 10,
}
impl SpecsEnvelopeKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "SPECS_ENVELOPE_KIND_UNKNOWN",
            Self::Done => "SPECS_ENVELOPE_KIND_DONE",
            Self::TopLevel => "SPECS_ENVELOPE_KIND_TOP_LEVEL",
            Self::FeatureGate => "SPECS_ENVELOPE_KIND_FEATURE_GATE",
            Self::DynamicConfig => "SPECS_ENVELOPE_KIND_DYNAMIC_CONFIG",
            Self::LayerConfig => "SPECS_ENVELOPE_KIND_LAYER_CONFIG",
            Self::ParamStore => "SPECS_ENVELOPE_KIND_PARAM_STORE",
            Self::Condition => "SPECS_ENVELOPE_KIND_CONDITION",
            Self::Deletions => "SPECS_ENVELOPE_KIND_DELETIONS",
            Self::Checksums => "SPECS_ENVELOPE_KIND_CHECKSUMS",
            Self::CopyPrev => "SPECS_ENVELOPE_KIND_COPY_PREV",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SPECS_ENVELOPE_KIND_UNKNOWN" => Some(Self::Unknown),
            "SPECS_ENVELOPE_KIND_DONE" => Some(Self::Done),
            "SPECS_ENVELOPE_KIND_TOP_LEVEL" => Some(Self::TopLevel),
            "SPECS_ENVELOPE_KIND_FEATURE_GATE" => Some(Self::FeatureGate),
            "SPECS_ENVELOPE_KIND_DYNAMIC_CONFIG" => Some(Self::DynamicConfig),
            "SPECS_ENVELOPE_KIND_LAYER_CONFIG" => Some(Self::LayerConfig),
            "SPECS_ENVELOPE_KIND_PARAM_STORE" => Some(Self::ParamStore),
            "SPECS_ENVELOPE_KIND_CONDITION" => Some(Self::Condition),
            "SPECS_ENVELOPE_KIND_DELETIONS" => Some(Self::Deletions),
            "SPECS_ENVELOPE_KIND_CHECKSUMS" => Some(Self::Checksums),
            "SPECS_ENVELOPE_KIND_COPY_PREV" => Some(Self::CopyPrev),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ConditionType {
    Unknown = 0,
    Public = 1,
    FailGate = 2,
    PassGate = 3,
    UaBased = 4,
    IpBased = 5,
    UserField = 6,
    EnvironmentField = 7,
    CurrentTime = 8,
    UserBucket = 9,
    TargetApp = 10,
    UnitId = 11,
}
impl ConditionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "CONDITION_TYPE_UNKNOWN",
            Self::Public => "CONDITION_TYPE_PUBLIC",
            Self::FailGate => "CONDITION_TYPE_FAIL_GATE",
            Self::PassGate => "CONDITION_TYPE_PASS_GATE",
            Self::UaBased => "CONDITION_TYPE_UA_BASED",
            Self::IpBased => "CONDITION_TYPE_IP_BASED",
            Self::UserField => "CONDITION_TYPE_USER_FIELD",
            Self::EnvironmentField => "CONDITION_TYPE_ENVIRONMENT_FIELD",
            Self::CurrentTime => "CONDITION_TYPE_CURRENT_TIME",
            Self::UserBucket => "CONDITION_TYPE_USER_BUCKET",
            Self::TargetApp => "CONDITION_TYPE_TARGET_APP",
            Self::UnitId => "CONDITION_TYPE_UNIT_ID",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONDITION_TYPE_UNKNOWN" => Some(Self::Unknown),
            "CONDITION_TYPE_PUBLIC" => Some(Self::Public),
            "CONDITION_TYPE_FAIL_GATE" => Some(Self::FailGate),
            "CONDITION_TYPE_PASS_GATE" => Some(Self::PassGate),
            "CONDITION_TYPE_UA_BASED" => Some(Self::UaBased),
            "CONDITION_TYPE_IP_BASED" => Some(Self::IpBased),
            "CONDITION_TYPE_USER_FIELD" => Some(Self::UserField),
            "CONDITION_TYPE_ENVIRONMENT_FIELD" => Some(Self::EnvironmentField),
            "CONDITION_TYPE_CURRENT_TIME" => Some(Self::CurrentTime),
            "CONDITION_TYPE_USER_BUCKET" => Some(Self::UserBucket),
            "CONDITION_TYPE_TARGET_APP" => Some(Self::TargetApp),
            "CONDITION_TYPE_UNIT_ID" => Some(Self::UnitId),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Operator {
    Unknown = 0,
    Gt = 1,
    Gte = 2,
    Lt = 3,
    Lte = 4,
    VersionGt = 5,
    VersionGte = 6,
    VersionLt = 7,
    VersionLte = 8,
    VersionEq = 9,
    VersionNeq = 10,
    Any = 11,
    None = 12,
    StrStartsWithAny = 13,
    StrEndsWithAny = 14,
    StrContainsAny = 15,
    StrContainsNone = 16,
    AnyCaseSensitive = 17,
    NoneCaseSensitive = 18,
    StrMatches = 19,
    Before = 20,
    After = 21,
    On = 22,
    Eq = 23,
    Neq = 24,
    InSegmentList = 25,
    NotInSegmentList = 26,
    ArrayContainsAny = 27,
    ArrayContainsNone = 28,
    ArrayContainsAll = 29,
    NotArrayContainsAll = 30,
    EncodedAny = 31,
}
impl Operator {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "OPERATOR_UNKNOWN",
            Self::Gt => "OPERATOR_GT",
            Self::Gte => "OPERATOR_GTE",
            Self::Lt => "OPERATOR_LT",
            Self::Lte => "OPERATOR_LTE",
            Self::VersionGt => "OPERATOR_VERSION_GT",
            Self::VersionGte => "OPERATOR_VERSION_GTE",
            Self::VersionLt => "OPERATOR_VERSION_LT",
            Self::VersionLte => "OPERATOR_VERSION_LTE",
            Self::VersionEq => "OPERATOR_VERSION_EQ",
            Self::VersionNeq => "OPERATOR_VERSION_NEQ",
            Self::Any => "OPERATOR_ANY",
            Self::None => "OPERATOR_NONE",
            Self::StrStartsWithAny => "OPERATOR_STR_STARTS_WITH_ANY",
            Self::StrEndsWithAny => "OPERATOR_STR_ENDS_WITH_ANY",
            Self::StrContainsAny => "OPERATOR_STR_CONTAINS_ANY",
            Self::StrContainsNone => "OPERATOR_STR_CONTAINS_NONE",
            Self::AnyCaseSensitive => "OPERATOR_ANY_CASE_SENSITIVE",
            Self::NoneCaseSensitive => "OPERATOR_NONE_CASE_SENSITIVE",
            Self::StrMatches => "OPERATOR_STR_MATCHES",
            Self::Before => "OPERATOR_BEFORE",
            Self::After => "OPERATOR_AFTER",
            Self::On => "OPERATOR_ON",
            Self::Eq => "OPERATOR_EQ",
            Self::Neq => "OPERATOR_NEQ",
            Self::InSegmentList => "OPERATOR_IN_SEGMENT_LIST",
            Self::NotInSegmentList => "OPERATOR_NOT_IN_SEGMENT_LIST",
            Self::ArrayContainsAny => "OPERATOR_ARRAY_CONTAINS_ANY",
            Self::ArrayContainsNone => "OPERATOR_ARRAY_CONTAINS_NONE",
            Self::ArrayContainsAll => "OPERATOR_ARRAY_CONTAINS_ALL",
            Self::NotArrayContainsAll => "OPERATOR_NOT_ARRAY_CONTAINS_ALL",
            Self::EncodedAny => "OPERATOR_ENCODED_ANY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OPERATOR_UNKNOWN" => Some(Self::Unknown),
            "OPERATOR_GT" => Some(Self::Gt),
            "OPERATOR_GTE" => Some(Self::Gte),
            "OPERATOR_LT" => Some(Self::Lt),
            "OPERATOR_LTE" => Some(Self::Lte),
            "OPERATOR_VERSION_GT" => Some(Self::VersionGt),
            "OPERATOR_VERSION_GTE" => Some(Self::VersionGte),
            "OPERATOR_VERSION_LT" => Some(Self::VersionLt),
            "OPERATOR_VERSION_LTE" => Some(Self::VersionLte),
            "OPERATOR_VERSION_EQ" => Some(Self::VersionEq),
            "OPERATOR_VERSION_NEQ" => Some(Self::VersionNeq),
            "OPERATOR_ANY" => Some(Self::Any),
            "OPERATOR_NONE" => Some(Self::None),
            "OPERATOR_STR_STARTS_WITH_ANY" => Some(Self::StrStartsWithAny),
            "OPERATOR_STR_ENDS_WITH_ANY" => Some(Self::StrEndsWithAny),
            "OPERATOR_STR_CONTAINS_ANY" => Some(Self::StrContainsAny),
            "OPERATOR_STR_CONTAINS_NONE" => Some(Self::StrContainsNone),
            "OPERATOR_ANY_CASE_SENSITIVE" => Some(Self::AnyCaseSensitive),
            "OPERATOR_NONE_CASE_SENSITIVE" => Some(Self::NoneCaseSensitive),
            "OPERATOR_STR_MATCHES" => Some(Self::StrMatches),
            "OPERATOR_BEFORE" => Some(Self::Before),
            "OPERATOR_AFTER" => Some(Self::After),
            "OPERATOR_ON" => Some(Self::On),
            "OPERATOR_EQ" => Some(Self::Eq),
            "OPERATOR_NEQ" => Some(Self::Neq),
            "OPERATOR_IN_SEGMENT_LIST" => Some(Self::InSegmentList),
            "OPERATOR_NOT_IN_SEGMENT_LIST" => Some(Self::NotInSegmentList),
            "OPERATOR_ARRAY_CONTAINS_ANY" => Some(Self::ArrayContainsAny),
            "OPERATOR_ARRAY_CONTAINS_NONE" => Some(Self::ArrayContainsNone),
            "OPERATOR_ARRAY_CONTAINS_ALL" => Some(Self::ArrayContainsAll),
            "OPERATOR_NOT_ARRAY_CONTAINS_ALL" => Some(Self::NotArrayContainsAll),
            "OPERATOR_ENCODED_ANY" => Some(Self::EncodedAny),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum KnownIdType {
    Unknown = 0,
    UserId = 1,
    StableId = 2,
}
impl KnownIdType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "KNOWN_ID_TYPE_UNKNOWN",
            Self::UserId => "KNOWN_ID_TYPE_USER_ID",
            Self::StableId => "KNOWN_ID_TYPE_STABLE_ID",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "KNOWN_ID_TYPE_UNKNOWN" => Some(Self::Unknown),
            "KNOWN_ID_TYPE_USER_ID" => Some(Self::UserId),
            "KNOWN_ID_TYPE_STABLE_ID" => Some(Self::StableId),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EntityType {
    EntityUnknown = 0,
    EntityFeatureGate = 1,
    EntityDynamicConfig = 2,
    EntityAutotune = 3,
    EntityExperiment = 4,
    EntityLayer = 5,
    EntitySegment = 6,
    EntityHoldout = 7,
}
impl EntityType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::EntityUnknown => "ENTITY_UNKNOWN",
            Self::EntityFeatureGate => "ENTITY_FEATURE_GATE",
            Self::EntityDynamicConfig => "ENTITY_DYNAMIC_CONFIG",
            Self::EntityAutotune => "ENTITY_AUTOTUNE",
            Self::EntityExperiment => "ENTITY_EXPERIMENT",
            Self::EntityLayer => "ENTITY_LAYER",
            Self::EntitySegment => "ENTITY_SEGMENT",
            Self::EntityHoldout => "ENTITY_HOLDOUT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ENTITY_UNKNOWN" => Some(Self::EntityUnknown),
            "ENTITY_FEATURE_GATE" => Some(Self::EntityFeatureGate),
            "ENTITY_DYNAMIC_CONFIG" => Some(Self::EntityDynamicConfig),
            "ENTITY_AUTOTUNE" => Some(Self::EntityAutotune),
            "ENTITY_EXPERIMENT" => Some(Self::EntityExperiment),
            "ENTITY_LAYER" => Some(Self::EntityLayer),
            "ENTITY_SEGMENT" => Some(Self::EntitySegment),
            "ENTITY_HOLDOUT" => Some(Self::EntityHoldout),
            _ => None,
        }
    }
}
